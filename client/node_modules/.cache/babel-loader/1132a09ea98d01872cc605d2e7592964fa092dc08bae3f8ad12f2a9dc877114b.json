{"ast":null,"code":"function CronJob(CronTime, spawn) {\n  function fnWrap(cmd) {\n    var command;\n    var args;\n    switch (typeof cmd) {\n      case 'string':\n        args = cmd.split(' ');\n        command = args.shift();\n        return spawn.bind(undefined, command, args);\n      case 'object':\n        command = cmd && cmd.command;\n        if (command) {\n          args = cmd.args;\n          var options = cmd.options;\n          return spawn.bind(undefined, command, args, options);\n        }\n        break;\n    }\n    return cmd;\n  }\n  function CJ(cronTime, onTick, onComplete, startNow, timeZone, context, runOnInit, utcOffset, unrefTimeout) {\n    var _cronTime = cronTime;\n    var argCount = 0;\n    for (var i = 0; i < arguments.length; i++) {\n      if (arguments[i] !== undefined) {\n        argCount++;\n      }\n    }\n    if (typeof cronTime !== 'string' && argCount === 1) {\n      // crontime is an object...\n      onTick = cronTime.onTick;\n      onComplete = cronTime.onComplete;\n      context = cronTime.context;\n      startNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n      timeZone = cronTime.timeZone;\n      runOnInit = cronTime.runOnInit;\n      _cronTime = cronTime.cronTime;\n      utcOffset = cronTime.utcOffset;\n      unrefTimeout = cronTime.unrefTimeout;\n    }\n    this.context = context || this;\n    this._callbacks = [];\n    this.onComplete = fnWrap(onComplete);\n    this.cronTime = new CronTime(_cronTime, timeZone, utcOffset);\n    this.unrefTimeout = unrefTimeout;\n    addCallback.call(this, fnWrap(onTick));\n    if (runOnInit) {\n      this.lastExecution = new Date();\n      fireOnTick.call(this);\n    }\n    if (startNow) {\n      start.call(this);\n    }\n    return this;\n  }\n  var addCallback = function (callback) {\n    if (typeof callback === 'function') {\n      this._callbacks.push(callback);\n    }\n  };\n  CJ.prototype.addCallback = addCallback;\n  CJ.prototype.setTime = function (time) {\n    if (typeof time !== 'object') {\n      // crontime is an object...\n      throw new Error('time must be an instance of CronTime.');\n    }\n    this.stop();\n    this.cronTime = time;\n    this.start();\n  };\n  CJ.prototype.nextDate = function () {\n    return this.cronTime.sendAt();\n  };\n  var fireOnTick = function () {\n    for (var i = this._callbacks.length - 1; i >= 0; i--) {\n      this._callbacks[i].call(this.context, this.onComplete);\n    }\n  };\n  CJ.prototype.fireOnTick = fireOnTick;\n  CJ.prototype.nextDates = function (i) {\n    return this.cronTime.sendAt(i);\n  };\n  var start = function () {\n    if (this.running) {\n      return;\n    }\n    var MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n    var self = this;\n    var timeout = this.cronTime.getTimeout();\n    var remaining = 0;\n    var startTime;\n    if (this.cronTime.realDate) {\n      this.runOnce = true;\n    }\n    function _setTimeout(timeout) {\n      startTime = Date.now();\n      self._timeout = setTimeout(callbackWrapper, timeout);\n      if (self.unrefTimeout && typeof self._timeout.unref === 'function') {\n        self._timeout.unref();\n      }\n    }\n\n    // The callback wrapper checks if it needs to sleep another period or not\n    // and does the real callback logic when it's time.\n    function callbackWrapper() {\n      var diff = startTime + timeout - Date.now();\n      if (diff > 0) {\n        var newTimeout = self.cronTime.getTimeout();\n        if (newTimeout > diff) {\n          newTimeout = diff;\n        }\n        remaining += newTimeout;\n      }\n\n      // If there is sleep time remaining, calculate how long and go to sleep\n      // again. This processing might make us miss the deadline by a few ms\n      // times the number of sleep sessions. Given a MAXDELAY of almost a\n      // month, this should be no issue.\n      self.lastExecution = new Date();\n      if (remaining) {\n        if (remaining > MAXDELAY) {\n          remaining -= MAXDELAY;\n          timeout = MAXDELAY;\n        } else {\n          timeout = remaining;\n          remaining = 0;\n        }\n        _setTimeout(timeout);\n      } else {\n        // We have arrived at the correct point in time.\n\n        self.running = false;\n\n        // start before calling back so the callbacks have the ability to stop the cron job\n        if (!self.runOnce) {\n          self.start();\n        }\n        self.fireOnTick();\n      }\n    }\n    if (timeout >= 0) {\n      this.running = true;\n\n      // Don't try to sleep more than MAXDELAY ms at a time.\n\n      if (timeout > MAXDELAY) {\n        remaining = timeout - MAXDELAY;\n        timeout = MAXDELAY;\n      }\n      _setTimeout(timeout);\n    } else {\n      this.stop();\n    }\n  };\n  CJ.prototype.start = start;\n  CJ.prototype.lastDate = function () {\n    return this.lastExecution;\n  };\n\n  /**\n   * Stop the cronjob.\n   */\n  CJ.prototype.stop = function () {\n    if (this._timeout) clearTimeout(this._timeout);\n    this.running = false;\n    if (typeof this.onComplete === 'function') {\n      this.onComplete();\n    }\n  };\n  return CJ;\n}\nmodule.exports = CronJob;","map":{"version":3,"names":["CronJob","CronTime","spawn","fnWrap","cmd","command","args","split","shift","bind","undefined","options","CJ","cronTime","onTick","onComplete","startNow","timeZone","context","runOnInit","utcOffset","unrefTimeout","_cronTime","argCount","i","arguments","length","start","startJob","_callbacks","addCallback","call","lastExecution","Date","fireOnTick","callback","push","prototype","setTime","time","Error","stop","nextDate","sendAt","nextDates","running","MAXDELAY","self","timeout","getTimeout","remaining","startTime","realDate","runOnce","_setTimeout","now","_timeout","setTimeout","callbackWrapper","unref","diff","newTimeout","lastDate","clearTimeout","module","exports"],"sources":["C:/Users/ritik/OneDrive/Desktop/React/nnnn/My_Timeline/client/node_modules/cron/lib/job.js"],"sourcesContent":["function CronJob(CronTime, spawn) {\n\tfunction fnWrap(cmd) {\n\t\tvar command;\n\t\tvar args;\n\n\t\tswitch (typeof cmd) {\n\t\t\tcase 'string':\n\t\t\t\targs = cmd.split(' ');\n\t\t\t\tcommand = args.shift();\n\n\t\t\t\treturn spawn.bind(undefined, command, args);\n\n\t\t\tcase 'object':\n\t\t\t\tcommand = cmd && cmd.command;\n\t\t\t\tif (command) {\n\t\t\t\t\targs = cmd.args;\n\t\t\t\t\tvar options = cmd.options;\n\n\t\t\t\t\treturn spawn.bind(undefined, command, args, options);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn cmd;\n\t}\n\n\tfunction CJ(\n\t\tcronTime,\n\t\tonTick,\n\t\tonComplete,\n\t\tstartNow,\n\t\ttimeZone,\n\t\tcontext,\n\t\trunOnInit,\n\t\tutcOffset,\n\t\tunrefTimeout\n\t) {\n\t\tvar _cronTime = cronTime;\n\t\tvar argCount = 0;\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tif (arguments[i] !== undefined) {\n\t\t\t\targCount++;\n\t\t\t}\n\t\t}\n\n\t\tif (typeof cronTime !== 'string' && argCount === 1) {\n\t\t\t// crontime is an object...\n\t\t\tonTick = cronTime.onTick;\n\t\t\tonComplete = cronTime.onComplete;\n\t\t\tcontext = cronTime.context;\n\t\t\tstartNow = cronTime.start || cronTime.startNow || cronTime.startJob;\n\t\t\ttimeZone = cronTime.timeZone;\n\t\t\trunOnInit = cronTime.runOnInit;\n\t\t\t_cronTime = cronTime.cronTime;\n\t\t\tutcOffset = cronTime.utcOffset;\n\t\t\tunrefTimeout = cronTime.unrefTimeout;\n\t\t}\n\n\t\tthis.context = context || this;\n\t\tthis._callbacks = [];\n\t\tthis.onComplete = fnWrap(onComplete);\n\t\tthis.cronTime = new CronTime(_cronTime, timeZone, utcOffset);\n\t\tthis.unrefTimeout = unrefTimeout;\n\n\t\taddCallback.call(this, fnWrap(onTick));\n\n\t\tif (runOnInit) {\n\t\t\tthis.lastExecution = new Date();\n\t\t\tfireOnTick.call(this);\n\t\t}\n\n\t\tif (startNow) {\n\t\t\tstart.call(this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tvar addCallback = function (callback) {\n\t\tif (typeof callback === 'function') {\n\t\t\tthis._callbacks.push(callback);\n\t\t}\n\t};\n\tCJ.prototype.addCallback = addCallback;\n\n\tCJ.prototype.setTime = function (time) {\n\t\tif (typeof time !== 'object') {\n\t\t\t// crontime is an object...\n\t\t\tthrow new Error('time must be an instance of CronTime.');\n\t\t}\n\t\tthis.stop();\n\t\tthis.cronTime = time;\n\t\tthis.start();\n\t};\n\n\tCJ.prototype.nextDate = function () {\n\t\treturn this.cronTime.sendAt();\n\t};\n\n\tvar fireOnTick = function () {\n\t\tfor (var i = this._callbacks.length - 1; i >= 0; i--) {\n\t\t\tthis._callbacks[i].call(this.context, this.onComplete);\n\t\t}\n\t};\n\tCJ.prototype.fireOnTick = fireOnTick;\n\n\tCJ.prototype.nextDates = function (i) {\n\t\treturn this.cronTime.sendAt(i);\n\t};\n\n\tvar start = function () {\n\t\tif (this.running) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar MAXDELAY = 2147483647; // The maximum number of milliseconds setTimeout will wait.\n\t\tvar self = this;\n\t\tvar timeout = this.cronTime.getTimeout();\n\t\tvar remaining = 0;\n\t\tvar startTime;\n\n\t\tif (this.cronTime.realDate) {\n\t\t\tthis.runOnce = true;\n\t\t}\n\n\t\tfunction _setTimeout(timeout) {\n\t\t\tstartTime = Date.now();\n\t\t\tself._timeout = setTimeout(callbackWrapper, timeout);\n\t\t\tif (self.unrefTimeout && typeof self._timeout.unref === 'function') {\n\t\t\t\tself._timeout.unref();\n\t\t\t}\n\t\t}\n\n\t\t// The callback wrapper checks if it needs to sleep another period or not\n\t\t// and does the real callback logic when it's time.\n\t\tfunction callbackWrapper() {\n\t\t\tvar diff = startTime + timeout - Date.now();\n\n\t\t\tif (diff > 0) {\n\t\t\t\tvar newTimeout = self.cronTime.getTimeout();\n\n\t\t\t\tif (newTimeout > diff) {\n\t\t\t\t\tnewTimeout = diff;\n\t\t\t\t}\n\n\t\t\t\tremaining += newTimeout;\n\t\t\t}\n\n\t\t\t// If there is sleep time remaining, calculate how long and go to sleep\n\t\t\t// again. This processing might make us miss the deadline by a few ms\n\t\t\t// times the number of sleep sessions. Given a MAXDELAY of almost a\n\t\t\t// month, this should be no issue.\n\t\t\tself.lastExecution = new Date();\n\t\t\tif (remaining) {\n\t\t\t\tif (remaining > MAXDELAY) {\n\t\t\t\t\tremaining -= MAXDELAY;\n\t\t\t\t\ttimeout = MAXDELAY;\n\t\t\t\t} else {\n\t\t\t\t\ttimeout = remaining;\n\t\t\t\t\tremaining = 0;\n\t\t\t\t}\n\n\t\t\t\t_setTimeout(timeout);\n\t\t\t} else {\n\t\t\t\t// We have arrived at the correct point in time.\n\n\t\t\t\tself.running = false;\n\n\t\t\t\t// start before calling back so the callbacks have the ability to stop the cron job\n\t\t\t\tif (!self.runOnce) {\n\t\t\t\t\tself.start();\n\t\t\t\t}\n\n\t\t\t\tself.fireOnTick();\n\t\t\t}\n\t\t}\n\n\t\tif (timeout >= 0) {\n\t\t\tthis.running = true;\n\n\t\t\t// Don't try to sleep more than MAXDELAY ms at a time.\n\n\t\t\tif (timeout > MAXDELAY) {\n\t\t\t\tremaining = timeout - MAXDELAY;\n\t\t\t\ttimeout = MAXDELAY;\n\t\t\t}\n\n\t\t\t_setTimeout(timeout);\n\t\t} else {\n\t\t\tthis.stop();\n\t\t}\n\t};\n\n\tCJ.prototype.start = start;\n\n\tCJ.prototype.lastDate = function () {\n\t\treturn this.lastExecution;\n\t};\n\n\t/**\n\t * Stop the cronjob.\n\t */\n\tCJ.prototype.stop = function () {\n\t\tif (this._timeout) clearTimeout(this._timeout);\n\t\tthis.running = false;\n\t\tif (typeof this.onComplete === 'function') {\n\t\t\tthis.onComplete();\n\t\t}\n\t};\n\n\treturn CJ;\n}\n\nmodule.exports = CronJob;\n"],"mappings":"AAAA,SAASA,OAAO,CAACC,QAAQ,EAAEC,KAAK,EAAE;EACjC,SAASC,MAAM,CAACC,GAAG,EAAE;IACpB,IAAIC,OAAO;IACX,IAAIC,IAAI;IAER,QAAQ,OAAOF,GAAG;MACjB,KAAK,QAAQ;QACZE,IAAI,GAAGF,GAAG,CAACG,KAAK,CAAC,GAAG,CAAC;QACrBF,OAAO,GAAGC,IAAI,CAACE,KAAK,EAAE;QAEtB,OAAON,KAAK,CAACO,IAAI,CAACC,SAAS,EAAEL,OAAO,EAAEC,IAAI,CAAC;MAE5C,KAAK,QAAQ;QACZD,OAAO,GAAGD,GAAG,IAAIA,GAAG,CAACC,OAAO;QAC5B,IAAIA,OAAO,EAAE;UACZC,IAAI,GAAGF,GAAG,CAACE,IAAI;UACf,IAAIK,OAAO,GAAGP,GAAG,CAACO,OAAO;UAEzB,OAAOT,KAAK,CAACO,IAAI,CAACC,SAAS,EAAEL,OAAO,EAAEC,IAAI,EAAEK,OAAO,CAAC;QACrD;QACA;IAAM;IAGR,OAAOP,GAAG;EACX;EAEA,SAASQ,EAAE,CACVC,QAAQ,EACRC,MAAM,EACNC,UAAU,EACVC,QAAQ,EACRC,QAAQ,EACRC,OAAO,EACPC,SAAS,EACTC,SAAS,EACTC,YAAY,EACX;IACD,IAAIC,SAAS,GAAGT,QAAQ;IACxB,IAAIU,QAAQ,GAAG,CAAC;IAChB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC1C,IAAIC,SAAS,CAACD,CAAC,CAAC,KAAKd,SAAS,EAAE;QAC/Ba,QAAQ,EAAE;MACX;IACD;IAEA,IAAI,OAAOV,QAAQ,KAAK,QAAQ,IAAIU,QAAQ,KAAK,CAAC,EAAE;MACnD;MACAT,MAAM,GAAGD,QAAQ,CAACC,MAAM;MACxBC,UAAU,GAAGF,QAAQ,CAACE,UAAU;MAChCG,OAAO,GAAGL,QAAQ,CAACK,OAAO;MAC1BF,QAAQ,GAAGH,QAAQ,CAACc,KAAK,IAAId,QAAQ,CAACG,QAAQ,IAAIH,QAAQ,CAACe,QAAQ;MACnEX,QAAQ,GAAGJ,QAAQ,CAACI,QAAQ;MAC5BE,SAAS,GAAGN,QAAQ,CAACM,SAAS;MAC9BG,SAAS,GAAGT,QAAQ,CAACA,QAAQ;MAC7BO,SAAS,GAAGP,QAAQ,CAACO,SAAS;MAC9BC,YAAY,GAAGR,QAAQ,CAACQ,YAAY;IACrC;IAEA,IAAI,CAACH,OAAO,GAAGA,OAAO,IAAI,IAAI;IAC9B,IAAI,CAACW,UAAU,GAAG,EAAE;IACpB,IAAI,CAACd,UAAU,GAAGZ,MAAM,CAACY,UAAU,CAAC;IACpC,IAAI,CAACF,QAAQ,GAAG,IAAIZ,QAAQ,CAACqB,SAAS,EAAEL,QAAQ,EAAEG,SAAS,CAAC;IAC5D,IAAI,CAACC,YAAY,GAAGA,YAAY;IAEhCS,WAAW,CAACC,IAAI,CAAC,IAAI,EAAE5B,MAAM,CAACW,MAAM,CAAC,CAAC;IAEtC,IAAIK,SAAS,EAAE;MACd,IAAI,CAACa,aAAa,GAAG,IAAIC,IAAI,EAAE;MAC/BC,UAAU,CAACH,IAAI,CAAC,IAAI,CAAC;IACtB;IAEA,IAAIf,QAAQ,EAAE;MACbW,KAAK,CAACI,IAAI,CAAC,IAAI,CAAC;IACjB;IAEA,OAAO,IAAI;EACZ;EAEA,IAAID,WAAW,GAAG,UAAUK,QAAQ,EAAE;IACrC,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MACnC,IAAI,CAACN,UAAU,CAACO,IAAI,CAACD,QAAQ,CAAC;IAC/B;EACD,CAAC;EACDvB,EAAE,CAACyB,SAAS,CAACP,WAAW,GAAGA,WAAW;EAEtClB,EAAE,CAACyB,SAAS,CAACC,OAAO,GAAG,UAAUC,IAAI,EAAE;IACtC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC7B;MACA,MAAM,IAAIC,KAAK,CAAC,uCAAuC,CAAC;IACzD;IACA,IAAI,CAACC,IAAI,EAAE;IACX,IAAI,CAAC5B,QAAQ,GAAG0B,IAAI;IACpB,IAAI,CAACZ,KAAK,EAAE;EACb,CAAC;EAEDf,EAAE,CAACyB,SAAS,CAACK,QAAQ,GAAG,YAAY;IACnC,OAAO,IAAI,CAAC7B,QAAQ,CAAC8B,MAAM,EAAE;EAC9B,CAAC;EAED,IAAIT,UAAU,GAAG,YAAY;IAC5B,KAAK,IAAIV,CAAC,GAAG,IAAI,CAACK,UAAU,CAACH,MAAM,GAAG,CAAC,EAAEF,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACrD,IAAI,CAACK,UAAU,CAACL,CAAC,CAAC,CAACO,IAAI,CAAC,IAAI,CAACb,OAAO,EAAE,IAAI,CAACH,UAAU,CAAC;IACvD;EACD,CAAC;EACDH,EAAE,CAACyB,SAAS,CAACH,UAAU,GAAGA,UAAU;EAEpCtB,EAAE,CAACyB,SAAS,CAACO,SAAS,GAAG,UAAUpB,CAAC,EAAE;IACrC,OAAO,IAAI,CAACX,QAAQ,CAAC8B,MAAM,CAACnB,CAAC,CAAC;EAC/B,CAAC;EAED,IAAIG,KAAK,GAAG,YAAY;IACvB,IAAI,IAAI,CAACkB,OAAO,EAAE;MACjB;IACD;IAEA,IAAIC,QAAQ,GAAG,UAAU,CAAC,CAAC;IAC3B,IAAIC,IAAI,GAAG,IAAI;IACf,IAAIC,OAAO,GAAG,IAAI,CAACnC,QAAQ,CAACoC,UAAU,EAAE;IACxC,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAIC,SAAS;IAEb,IAAI,IAAI,CAACtC,QAAQ,CAACuC,QAAQ,EAAE;MAC3B,IAAI,CAACC,OAAO,GAAG,IAAI;IACpB;IAEA,SAASC,WAAW,CAACN,OAAO,EAAE;MAC7BG,SAAS,GAAGlB,IAAI,CAACsB,GAAG,EAAE;MACtBR,IAAI,CAACS,QAAQ,GAAGC,UAAU,CAACC,eAAe,EAAEV,OAAO,CAAC;MACpD,IAAID,IAAI,CAAC1B,YAAY,IAAI,OAAO0B,IAAI,CAACS,QAAQ,CAACG,KAAK,KAAK,UAAU,EAAE;QACnEZ,IAAI,CAACS,QAAQ,CAACG,KAAK,EAAE;MACtB;IACD;;IAEA;IACA;IACA,SAASD,eAAe,GAAG;MAC1B,IAAIE,IAAI,GAAGT,SAAS,GAAGH,OAAO,GAAGf,IAAI,CAACsB,GAAG,EAAE;MAE3C,IAAIK,IAAI,GAAG,CAAC,EAAE;QACb,IAAIC,UAAU,GAAGd,IAAI,CAAClC,QAAQ,CAACoC,UAAU,EAAE;QAE3C,IAAIY,UAAU,GAAGD,IAAI,EAAE;UACtBC,UAAU,GAAGD,IAAI;QAClB;QAEAV,SAAS,IAAIW,UAAU;MACxB;;MAEA;MACA;MACA;MACA;MACAd,IAAI,CAACf,aAAa,GAAG,IAAIC,IAAI,EAAE;MAC/B,IAAIiB,SAAS,EAAE;QACd,IAAIA,SAAS,GAAGJ,QAAQ,EAAE;UACzBI,SAAS,IAAIJ,QAAQ;UACrBE,OAAO,GAAGF,QAAQ;QACnB,CAAC,MAAM;UACNE,OAAO,GAAGE,SAAS;UACnBA,SAAS,GAAG,CAAC;QACd;QAEAI,WAAW,CAACN,OAAO,CAAC;MACrB,CAAC,MAAM;QACN;;QAEAD,IAAI,CAACF,OAAO,GAAG,KAAK;;QAEpB;QACA,IAAI,CAACE,IAAI,CAACM,OAAO,EAAE;UAClBN,IAAI,CAACpB,KAAK,EAAE;QACb;QAEAoB,IAAI,CAACb,UAAU,EAAE;MAClB;IACD;IAEA,IAAIc,OAAO,IAAI,CAAC,EAAE;MACjB,IAAI,CAACH,OAAO,GAAG,IAAI;;MAEnB;;MAEA,IAAIG,OAAO,GAAGF,QAAQ,EAAE;QACvBI,SAAS,GAAGF,OAAO,GAAGF,QAAQ;QAC9BE,OAAO,GAAGF,QAAQ;MACnB;MAEAQ,WAAW,CAACN,OAAO,CAAC;IACrB,CAAC,MAAM;MACN,IAAI,CAACP,IAAI,EAAE;IACZ;EACD,CAAC;EAED7B,EAAE,CAACyB,SAAS,CAACV,KAAK,GAAGA,KAAK;EAE1Bf,EAAE,CAACyB,SAAS,CAACyB,QAAQ,GAAG,YAAY;IACnC,OAAO,IAAI,CAAC9B,aAAa;EAC1B,CAAC;;EAED;AACD;AACA;EACCpB,EAAE,CAACyB,SAAS,CAACI,IAAI,GAAG,YAAY;IAC/B,IAAI,IAAI,CAACe,QAAQ,EAAEO,YAAY,CAAC,IAAI,CAACP,QAAQ,CAAC;IAC9C,IAAI,CAACX,OAAO,GAAG,KAAK;IACpB,IAAI,OAAO,IAAI,CAAC9B,UAAU,KAAK,UAAU,EAAE;MAC1C,IAAI,CAACA,UAAU,EAAE;IAClB;EACD,CAAC;EAED,OAAOH,EAAE;AACV;AAEAoD,MAAM,CAACC,OAAO,GAAGjE,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}