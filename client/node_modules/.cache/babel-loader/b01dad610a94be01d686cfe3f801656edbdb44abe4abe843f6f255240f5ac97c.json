{"ast":null,"code":"const validatePattern = require('./pattern-validation');\nconst convertExpression = require('./convert-expression');\nfunction matchPattern(pattern, value) {\n  if (pattern.indexOf(',') !== -1) {\n    const patterns = pattern.split(',');\n    return patterns.indexOf(value.toString()) !== -1;\n  }\n  return pattern === value.toString();\n}\nclass TimeMatcher {\n  constructor(pattern, timezone) {\n    validatePattern(pattern);\n    this.pattern = convertExpression(pattern);\n    this.timezone = timezone;\n    this.expressions = this.pattern.split(' ');\n  }\n  match(date) {\n    date = this.apply(date);\n    const runOnSecond = matchPattern(this.expressions[0], date.getSeconds());\n    const runOnMinute = matchPattern(this.expressions[1], date.getMinutes());\n    const runOnHour = matchPattern(this.expressions[2], date.getHours());\n    const runOnDay = matchPattern(this.expressions[3], date.getDate());\n    const runOnMonth = matchPattern(this.expressions[4], date.getMonth() + 1);\n    const runOnWeekDay = matchPattern(this.expressions[5], date.getDay());\n    return runOnSecond && runOnMinute && runOnHour && runOnDay && runOnMonth && runOnWeekDay;\n  }\n  apply(date) {\n    if (this.timezone) {\n      const dtf = new Intl.DateTimeFormat('en-US', {\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        hourCycle: 'h23',\n        fractionalSecondDigits: 3,\n        timeZone: this.timezone\n      });\n      return new Date(dtf.format(date));\n    }\n    return date;\n  }\n}\nmodule.exports = TimeMatcher;","map":{"version":3,"names":["validatePattern","require","convertExpression","matchPattern","pattern","value","indexOf","patterns","split","toString","TimeMatcher","constructor","timezone","expressions","match","date","apply","runOnSecond","getSeconds","runOnMinute","getMinutes","runOnHour","getHours","runOnDay","getDate","runOnMonth","getMonth","runOnWeekDay","getDay","dtf","Intl","DateTimeFormat","year","month","day","hour","minute","second","hourCycle","fractionalSecondDigits","timeZone","Date","format","module","exports"],"sources":["C:/Users/ritik/OneDrive/Desktop/React/nnnn/My_Timeline/client/node_modules/node-cron/src/time-matcher.js"],"sourcesContent":["const validatePattern = require('./pattern-validation');\nconst convertExpression = require('./convert-expression');\n\nfunction matchPattern(pattern, value){\n    if( pattern.indexOf(',') !== -1 ){\n        const patterns = pattern.split(',');\n        return patterns.indexOf(value.toString()) !== -1;\n    }\n    return pattern === value.toString();\n}\n\nclass TimeMatcher{\n    constructor(pattern, timezone){\n        validatePattern(pattern);\n        this.pattern = convertExpression(pattern);\n        this.timezone = timezone;\n        this.expressions = this.pattern.split(' ');\n    }\n\n    match(date){\n        date = this.apply(date);\n\n        const runOnSecond = matchPattern(this.expressions[0], date.getSeconds());\n        const runOnMinute = matchPattern(this.expressions[1], date.getMinutes());\n        const runOnHour = matchPattern(this.expressions[2], date.getHours());\n        const runOnDay = matchPattern(this.expressions[3], date.getDate());\n        const runOnMonth = matchPattern(this.expressions[4], date.getMonth() + 1);\n        const runOnWeekDay = matchPattern(this.expressions[5], date.getDay());\n\n        return runOnSecond && runOnMinute && runOnHour && runOnDay && runOnMonth && runOnWeekDay;\n    }\n\n    apply(date){\n        if(this.timezone){\n            const dtf = new Intl.DateTimeFormat('en-US', {\n                year: 'numeric',\n                month: '2-digit',\n                day: '2-digit',\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit',\n                hourCycle: 'h23',\n                fractionalSecondDigits: 3,\n                timeZone: this.timezone\n            });\n            \n            return new Date(dtf.format(date));\n        }\n        \n        return date;\n    }\n}\n\nmodule.exports = TimeMatcher;"],"mappings":"AAAA,MAAMA,eAAe,GAAGC,OAAO,CAAC,sBAAsB,CAAC;AACvD,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AAEzD,SAASE,YAAY,CAACC,OAAO,EAAEC,KAAK,EAAC;EACjC,IAAID,OAAO,CAACE,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;IAC7B,MAAMC,QAAQ,GAAGH,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC;IACnC,OAAOD,QAAQ,CAACD,OAAO,CAACD,KAAK,CAACI,QAAQ,EAAE,CAAC,KAAK,CAAC,CAAC;EACpD;EACA,OAAOL,OAAO,KAAKC,KAAK,CAACI,QAAQ,EAAE;AACvC;AAEA,MAAMC,WAAW;EACbC,WAAW,CAACP,OAAO,EAAEQ,QAAQ,EAAC;IAC1BZ,eAAe,CAACI,OAAO,CAAC;IACxB,IAAI,CAACA,OAAO,GAAGF,iBAAiB,CAACE,OAAO,CAAC;IACzC,IAAI,CAACQ,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,WAAW,GAAG,IAAI,CAACT,OAAO,CAACI,KAAK,CAAC,GAAG,CAAC;EAC9C;EAEAM,KAAK,CAACC,IAAI,EAAC;IACPA,IAAI,GAAG,IAAI,CAACC,KAAK,CAACD,IAAI,CAAC;IAEvB,MAAME,WAAW,GAAGd,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACG,UAAU,EAAE,CAAC;IACxE,MAAMC,WAAW,GAAGhB,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACK,UAAU,EAAE,CAAC;IACxE,MAAMC,SAAS,GAAGlB,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACO,QAAQ,EAAE,CAAC;IACpE,MAAMC,QAAQ,GAAGpB,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACS,OAAO,EAAE,CAAC;IAClE,MAAMC,UAAU,GAAGtB,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACW,QAAQ,EAAE,GAAG,CAAC,CAAC;IACzE,MAAMC,YAAY,GAAGxB,YAAY,CAAC,IAAI,CAACU,WAAW,CAAC,CAAC,CAAC,EAAEE,IAAI,CAACa,MAAM,EAAE,CAAC;IAErE,OAAOX,WAAW,IAAIE,WAAW,IAAIE,SAAS,IAAIE,QAAQ,IAAIE,UAAU,IAAIE,YAAY;EAC5F;EAEAX,KAAK,CAACD,IAAI,EAAC;IACP,IAAG,IAAI,CAACH,QAAQ,EAAC;MACb,MAAMiB,GAAG,GAAG,IAAIC,IAAI,CAACC,cAAc,CAAC,OAAO,EAAE;QACzCC,IAAI,EAAE,SAAS;QACfC,KAAK,EAAE,SAAS;QAChBC,GAAG,EAAE,SAAS;QACdC,IAAI,EAAE,SAAS;QACfC,MAAM,EAAE,SAAS;QACjBC,MAAM,EAAE,SAAS;QACjBC,SAAS,EAAE,KAAK;QAChBC,sBAAsB,EAAE,CAAC;QACzBC,QAAQ,EAAE,IAAI,CAAC5B;MACnB,CAAC,CAAC;MAEF,OAAO,IAAI6B,IAAI,CAACZ,GAAG,CAACa,MAAM,CAAC3B,IAAI,CAAC,CAAC;IACrC;IAEA,OAAOA,IAAI;EACf;AACJ;AAEA4B,MAAM,CAACC,OAAO,GAAGlC,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}