{"ast":null,"code":"'use strict';\n\nmodule.exports = (() => {\n  function convertSteps(expressions) {\n    var stepValuePattern = /^(.+)\\/(\\w+)$/;\n    for (var i = 0; i < expressions.length; i++) {\n      var match = stepValuePattern.exec(expressions[i]);\n      var isStepValue = match !== null && match.length > 0;\n      if (isStepValue) {\n        var baseDivider = match[2];\n        if (isNaN(baseDivider)) {\n          throw baseDivider + ' is not a valid step value';\n        }\n        var values = match[1].split(',');\n        var stepValues = [];\n        var divider = parseInt(baseDivider, 10);\n        for (var j = 0; j <= values.length; j++) {\n          var value = parseInt(values[j], 10);\n          if (value % divider === 0) {\n            stepValues.push(value);\n          }\n        }\n        expressions[i] = stepValues.join(',');\n      }\n    }\n    return expressions;\n  }\n  return convertSteps;\n})();","map":{"version":3,"names":["module","exports","convertSteps","expressions","stepValuePattern","i","length","match","exec","isStepValue","baseDivider","isNaN","values","split","stepValues","divider","parseInt","j","value","push","join"],"sources":["C:/Users/ritik/OneDrive/Desktop/React/nnnn/My_Timeline/client/node_modules/node-cron/src/convert-expression/step-values-conversion.js"],"sourcesContent":["'use strict';\n\nmodule.exports = (() => {\n    function convertSteps(expressions){\n        var stepValuePattern = /^(.+)\\/(\\w+)$/;\n        for(var i = 0; i < expressions.length; i++){\n            var match = stepValuePattern.exec(expressions[i]);\n            var isStepValue = match !== null && match.length > 0;\n            if(isStepValue){\n                var baseDivider = match[2];\n                if(isNaN(baseDivider)){\n                    throw baseDivider + ' is not a valid step value';\n                }\n                var values = match[1].split(',');\n                var stepValues = [];\n                var divider = parseInt(baseDivider, 10);\n                for(var j = 0; j <= values.length; j++){\n                    var value = parseInt(values[j], 10);\n                    if(value % divider === 0){\n                        stepValues.push(value);\n                    }\n                }\n                expressions[i] = stepValues.join(',');\n            }\n        }\n        return expressions;\n    }\n\n    return convertSteps;\n})();\n"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAG,CAAC,MAAM;EACpB,SAASC,YAAY,CAACC,WAAW,EAAC;IAC9B,IAAIC,gBAAgB,GAAG,eAAe;IACtC,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,WAAW,CAACG,MAAM,EAAED,CAAC,EAAE,EAAC;MACvC,IAAIE,KAAK,GAAGH,gBAAgB,CAACI,IAAI,CAACL,WAAW,CAACE,CAAC,CAAC,CAAC;MACjD,IAAII,WAAW,GAAGF,KAAK,KAAK,IAAI,IAAIA,KAAK,CAACD,MAAM,GAAG,CAAC;MACpD,IAAGG,WAAW,EAAC;QACX,IAAIC,WAAW,GAAGH,KAAK,CAAC,CAAC,CAAC;QAC1B,IAAGI,KAAK,CAACD,WAAW,CAAC,EAAC;UAClB,MAAMA,WAAW,GAAG,4BAA4B;QACpD;QACA,IAAIE,MAAM,GAAGL,KAAK,CAAC,CAAC,CAAC,CAACM,KAAK,CAAC,GAAG,CAAC;QAChC,IAAIC,UAAU,GAAG,EAAE;QACnB,IAAIC,OAAO,GAAGC,QAAQ,CAACN,WAAW,EAAE,EAAE,CAAC;QACvC,KAAI,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIL,MAAM,CAACN,MAAM,EAAEW,CAAC,EAAE,EAAC;UACnC,IAAIC,KAAK,GAAGF,QAAQ,CAACJ,MAAM,CAACK,CAAC,CAAC,EAAE,EAAE,CAAC;UACnC,IAAGC,KAAK,GAAGH,OAAO,KAAK,CAAC,EAAC;YACrBD,UAAU,CAACK,IAAI,CAACD,KAAK,CAAC;UAC1B;QACJ;QACAf,WAAW,CAACE,CAAC,CAAC,GAAGS,UAAU,CAACM,IAAI,CAAC,GAAG,CAAC;MACzC;IACJ;IACA,OAAOjB,WAAW;EACtB;EAEA,OAAOD,YAAY;AACvB,CAAC,GAAG"},"metadata":{},"sourceType":"script","externalDependencies":[]}